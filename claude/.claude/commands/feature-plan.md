---
description: Full product-to-architecture feature planning pipeline. Runs product spec, UX research, and backend/frontend architects to produce a comprehensive feature spec.
allowed-tools: [Task, Read, Write, Glob, Grep, AskUserQuestion]
---

# Feature Plan Pipeline

Run a full product-to-architecture planning pipeline for a new feature. This produces a comprehensive feature spec document without writing any implementation code.

## Pipeline Flow

```
1. Product Spec Agent → defines WHAT to build and WHY
2. USER CHECKPOINT → approve the product spec before continuing
3. UX Researcher + Backend Architect → run in PARALLEL
   (UX recommends patterns/flows, Backend defines API contract)
4. Frontend Architect → designs UI against UX recommendations + API contract
5. Write FEATURE_SPEC.md → unified spec document
```

## Instructions

### Step 1: Product Specification

Launch the product-spec-manager agent (`subagent_type: product-spec-manager`):
- Pass the feature description below
- Instruct it to define: problem statement, user stories, success criteria, scope boundaries, and priority
- Instruct it to examine the existing codebase and any existing product specs in `/product-specs/` for context
- Tell it to NOT create or write any files — just return the analysis as text output
- The output should follow its standard spec format but returned as text, not written to disk

### Step 2: User Checkpoint

Present the product spec to the user clearly and concisely. Ask if they want to:
- **Approve** and continue to UX + architecture planning
- **Modify** the scope or direction before continuing

Do NOT proceed past this point without user approval.

### Step 3: UX Research + Backend Architecture (PARALLEL)

Launch BOTH agents in parallel using a single message with multiple Task tool calls:

**UX Research Analyst** (`subagent_type: ux-research-analyst`):
- Pass the approved product spec
- Instruct it to recommend UX patterns, user flows, interaction design, and information architecture for this feature
- If there is an existing frontend codebase, instruct it to analyze existing patterns and recommend consistency
- If this is greenfield, instruct it to recommend best practices for the feature type
- Tell it to focus on: component patterns, user flow steps, feedback/loading states, error handling UX, accessibility considerations, and responsive behavior

**Backend Architect** (`subagent_type: backend-architect`):
- Pass the approved product spec
- Instruct it to explore the codebase, search for existing patterns, and produce a detailed implementation plan
- The plan MUST include a clearly defined **API contract** section specifying: endpoint URLs, HTTP methods, request body shapes, response shapes, status codes, and any query parameters or pagination
- Also include: data models with field types/indexes/constraints, serializer definitions, viewset structure, Celery tasks if needed, and migration strategy

### Step 4: Frontend Architecture

Launch the frontend-architect agent (`subagent_type: frontend-architect`):
- Pass the feature description, the UX researcher's recommendations, AND the backend API contract
- Instruct it to design the frontend implementation that:
  - Follows the UX researcher's recommended patterns and flows
  - Integrates against the exact API contract from the backend architect
  - Must NOT invent its own endpoint shapes
- The plan should include: component hierarchy, props/emits interfaces, state management approach, styling approach, API integration points, and existing components to reuse

### Step 5: Write the Feature Spec

Derive a filename from the feature name (kebab-case, e.g., `user-notifications.md`).

Write a unified spec document to `/product-specs/FEATURE_NAME.md` with this structure:

```markdown
# [Feature Name]

> Generated by /feature-plan pipeline

## Product Specification

### Problem Statement
[From product spec agent]

### User Stories
[From product spec agent]

### Success Criteria
[From product spec agent]

### Scope
[In scope / out of scope from product spec agent]

---

## UX Design

### Recommended User Flows
[From UX researcher]

### Interaction Patterns
[From UX researcher]

### Accessibility & Responsive Notes
[From UX researcher]

---

## API Contract

[Full API contract from backend architect — this is the bridge between backend and frontend]

---

## Backend Architecture

### Data Models
[From backend architect]

### Serializers & Views
[From backend architect]

### Async Tasks
[From backend architect, if applicable]

### Migration Strategy
[From backend architect]

---

## Frontend Architecture

### Component Hierarchy
[From frontend architect]

### State Management
[From frontend architect]

### API Integration
[From frontend architect, referencing the API contract]

### Styling Approach
[From frontend architect]

---

## Implementation Notes

### Suggested Build Order
1. Backend: models + migrations
2. Backend: serializers + views
3. Frontend: stores + API composables
4. Frontend: components + pages

### Open Questions
[Any unresolved items from any agent]
```

### Step 6: Present Summary

After writing the file, present a concise summary to the user:
- Where the spec was saved
- Key decisions made across all stages
- Any open questions or concerns flagged by any agent
- Remind the user they can use `/be-plan` and `/fe-plan` (or `/fs-plan`) to implement from this spec

## Feature

$ARGUMENTS
